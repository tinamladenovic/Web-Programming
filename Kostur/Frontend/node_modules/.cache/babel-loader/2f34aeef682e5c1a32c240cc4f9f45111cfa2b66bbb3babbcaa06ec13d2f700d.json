{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { BooleanType, CallExpression, ColorType, NoneType, NumberArrayType, NumberType, Ops, SizeType, StringType, computeGeometryType, isType, overlapsType, parse, typeName } from './expression.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray } from '../color.js';\nimport { toSize } from '../size.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/**\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\n * @param {number|import('../size.js').Size} size Size.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function sizeToGlsl(size) {\n  const array = toSize(size);\n  return arrayToGlsl(array);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {}\n  };\n}\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(encoded, type, parsingContext, compilationContext) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const propName = /** @type {string} */firstArg.value;\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const isExisting = (propName in context.properties);\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: feature => {\n          return computeGeometryType(feature.getGeometry());\n        }\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const varName = /** @type {string} */firstArg.value;\n    const isExisting = (varName in context.variables);\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler(compiledArgs => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler(compiledArgs => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`),\n  [Ops.NotEqual]: createCompiler(([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`),\n  [Ops.GreaterThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`),\n  [Ops.LessThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`),\n  [Ops.LessThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`),\n  [Ops.Multiply]: createCompiler(compiledArgs => `(${compiledArgs.join(' * ')})`),\n  [Ops.Divide]: createCompiler(([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`),\n  [Ops.Add]: createCompiler(compiledArgs => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`),\n  [Ops.Clamp]: createCompiler(([value, min, max]) => `clamp(${value}, ${min}, ${max})`),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined ? `atan(${firstValue}, ${secondValue})` : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler(compiledArgs => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler(compiledArgs => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(args => `vec${args.length}(${args.join(', ')})`),\n  [Ops.Color]: createCompiler(compiledArgs => {\n    if (compiledArgs.length === 1) {\n      //grayscale\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\n    }\n    if (compiledArgs.length === 2) {\n      //grayscale with alpha\n      return `(${compiledArgs[1]} * vec4(vec3(${compiledArgs[0]} / 255.0), 1.0))`;\n    }\n    const rgb = compiledArgs.slice(0, 3).map(color => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${yOffset ?? '0.0'})`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */\n      /** @type {LiteralExpression} */colors[i].value;\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Coalesce\n  // Ops.Concat\n  // Ops.ToString\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(`No compiler defined for this operator: ${JSON.stringify(expression.operator)}`);\n    }\n    return compiler(context, expression, returnType);\n  }\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl( /** @type {number} */expression.value);\n  }\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl( /** @type {Array<number> | string} */expression.value);\n  }\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl( /** @type {Array<number>} */expression.value);\n  }\n  if ((expression.type & SizeType) > 0) {\n    return sizeToGlsl( /** @type {number|import('../size.js').Size} */expression.value);\n  }\n  throw new Error(`Unexpected expression ${expression.value} (expected type ${typeName(returnType)})`);\n}","map":{"version":3,"names":["PaletteTexture","BooleanType","CallExpression","ColorType","NoneType","NumberArrayType","NumberType","Ops","SizeType","StringType","computeGeometryType","isType","overlapsType","parse","typeName","Uniforms","asArray","toSize","computeOperatorFunctionName","operator","context","Object","keys","functions","length","numberToGlsl","v","s","toString","includes","arrayToGlsl","array","Error","map","join","colorToGlsl","color","alpha","sizeToGlsl","size","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","inFragmentShader","variables","properties","bandCount","style","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","encoded","type","parsingContext","compilationContext","expression","expected","actual","compile","createCompiler","output","args","Array","i","compilers","Get","firstArg","propName","value","isExisting","name","prefix","GeometryType","evaluator","feature","getGeometry","Var","varName","Resolution","Zoom","Time","Any","compiledArgs","All","Not","Equal","firstValue","secondValue","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","min","max","Mod","modulo","Pow","power","Abs","Floor","Ceil","Round","Sin","Cos","Atan","undefined","Sqrt","Match","input","fallback","result","match","Between","Interpolate","exponent","stop1","output1","stop2","output2","ratio","Case","condition","In","needle","haystack","funcName","tests","push","Color","rgb","slice","Band","band","xOffset","yOffset","ifBlocks","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","Palette","index","colors","numColors","palette","Uint8Array","parsedValue","offset","paletteTextures","paletteName","paletteTexture","compiledIndex","returnType","compiler","JSON","stringify"],"sources":["C:/Users/PC/eclipse-workspace/apache-tomcat-9.0.89/apache-tomcat-9.0.89/webapps/chocolate-factory-2/Kostur/Frontend/front-app/node_modules/ol/expr/gpu.js"],"sourcesContent":["/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {\n  BooleanType,\n  CallExpression,\n  ColorType,\n  NoneType,\n  NumberArrayType,\n  NumberType,\n  Ops,\n  SizeType,\n  StringType,\n  computeGeometryType,\n  isType,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray} from '../color.js';\nimport {toSize} from '../size.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.',\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/**\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\n * @param {number|import('../size.js').Size} size Size.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function sizeToGlsl(size) {\n  const array = toSize(size);\n  return arrayToGlsl(array);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {},\n  };\n}\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(\n  encoded,\n  type,\n  parsingContext,\n  compilationContext,\n) {\n  const expression = parse(encoded, parsingContext, type);\n  if (isType(expression.type, NoneType)) {\n    throw new Error(`No matching type was found`);\n  }\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`,\n    );\n  }\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const propName = /** @type {string} */ (firstArg.value);\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type,\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: (feature) => {\n          return computeGeometryType(feature.getGeometry());\n        },\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const varName = /** @type {string} */ (firstArg.value);\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type,\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`,\n  ),\n  [Ops.NotEqual]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`,\n  ),\n  [Ops.GreaterThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`,\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`,\n  ),\n  [Ops.LessThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`,\n  ),\n  [Ops.LessThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`,\n  ),\n  [Ops.Multiply]: createCompiler(\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`,\n  ),\n  [Ops.Divide]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`,\n  ),\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`,\n  ),\n  [Ops.Clamp]: createCompiler(\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`,\n  ),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined\n      ? `atan(${firstValue}, ${secondValue})`\n      : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler((compiledArgs) => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`,\n  ),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler((compiledArgs) => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(\n    (args) => `vec${args.length}(${args.join(', ')})`,\n  ),\n  [Ops.Color]: createCompiler((compiledArgs) => {\n    if (compiledArgs.length === 1) {\n      //grayscale\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\n    }\n    if (compiledArgs.length === 2) {\n      //grayscale with alpha\n      return `(${compiledArgs[1]} * vec4(vec3(${compiledArgs[0]} / 255.0), 1.0))`;\n    }\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `(${alpha} * vec4(${rgb.join(', ')}, 1.0))`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] =\n        `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\n      yOffset ?? '0.0'\n    })`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */ (\n        /** @type {LiteralExpression} */ (colors[i]).value\n      );\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Coalesce\n  // Ops.Concat\n  // Ops.ToString\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\n        `No compiler defined for this operator: ${JSON.stringify(\n          expression.operator,\n        )}`,\n      );\n    }\n    return compiler(context, expression, returnType);\n  }\n\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */ (expression.value));\n  }\n\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(\n      /** @type {Array<number> | string} */ (expression.value),\n    );\n  }\n\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\n  }\n\n  if ((expression.type & SizeType) > 0) {\n    return sizeToGlsl(\n      /** @type {number|import('../size.js').Size} */ (expression.value),\n    );\n  }\n\n  throw new Error(\n    `Unexpected expression ${expression.value} (expected type ${typeName(\n      returnType,\n    )})`,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}