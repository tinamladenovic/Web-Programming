{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n/**\n * @module ol/source/ogcTileUtil\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { getJSON, resolveUrl } from '../net.js';\nimport { get as getProjection } from '../proj.js';\nimport { getIntersection as intersectExtents } from '../extent.js';\nimport { error as logError } from '../console.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n  if (url.pathname.split('/').includes('collections')) {\n    logError('The \"collections\" query parameter cannot be added to collection endpoints');\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections.map(c => encodeURIComponent(c)).join(',');\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(links, mediaType, supportedMediaTypes, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    projection = getProjection(tileMatrixSet.crs);\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${tileMatrixSet.crs}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const backwards = (orderedAxes ? orderedAxes.slice(0, 2).map(s => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n')).join('') : projection.getAxisOrientation().substr(0, 2)) !== 'en';\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined\n  });\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2]\n    };\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (localContext.tileCol < limit.minTileCol || localContext.tileCol > limit.maxTileCol || localContext.tileRow < limit.minTileRow || localContext.tileRow > limit.maxTileRow) {\n        return undefined;\n      }\n    }\n    Object.assign(localContext, context);\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n    return resolveUrl(base, url);\n  }\n  return {\n    grid: tileGrid,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(tileSet.links, sourceInfo.mediaType, sourceInfo.collections);\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(tileSet.links, sourceInfo.mediaType, sourceInfo.supportedMediaTypes, sourceInfo.collections);\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(sourceInfo, tileSet.tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);\n  }\n  const tileMatrixSetLink = tileSet.links.find(link => link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme');\n  if (!tileMatrixSetLink) {\n    throw new Error('Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet');\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}","map":{"version":3,"names":["TileGrid","getJSON","resolveUrl","get","getProjection","getIntersection","intersectExtents","error","logError","knownMapMediaTypes","knownVectorMediaTypes","appendCollectionsQueryParam","tileUrlTemplate","collections","length","url","URL","pathname","split","includes","encodedCollections","map","c","encodeURIComponent","join","searchParams","append","baseUrl","queryParams","decodeURIComponent","toString","getMapTileUrlTemplate","links","mediaType","fallbackUrlTemplate","i","link","rel","type","href","startsWith","Error","getVectorTileUrlTemplate","supportedMediaTypes","hrefLookup","supportedMediaType","parseTileMatrixSet","sourceInfo","tileMatrixSet","tileMatrixSetLimits","projection","crs","orderedAxes","backwards","slice","s","replace","getAxisOrientation","substr","matrices","tileMatrices","matrixLookup","matrix","id","limitLookup","matrixIds","limit","tileMatrix","push","origins","Array","resolutions","sizes","tileSizes","extent","Infinity","origin","pointOfOrigin","cellSize","matrixWidth","matrixHeight","tileWidth","tileHeight","tileMapWidth","minX","minTileCol","maxX","maxTileCol","tileMapHeight","upsideDown","cornerOfOrigin","minY","maxY","minTileRow","maxTileRow","tileGrid","undefined","context","base","tileUrlFunction","tileCoord","pixelRatio","localContext","tileCol","tileRow","Object","assign","m","p","grid","urlTemplate","urlFunction","parseTileSetMetadata","tileSet","dataType","tileMatrixSetLink","find","tileMatrixSetDefinition","then","getTileSetInfo"],"sources":["C:/Users/PC/eclipse-workspace/apache-tomcat-9.0.89/apache-tomcat-9.0.89/webapps/chocolate-factory-2/Kostur/Frontend/front-app/node_modules/ol/source/ogcTileUtil.js"],"sourcesContent":["/**\n * @module ol/source/ogcTileUtil\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\nimport {error as logError} from '../console.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string} crs The coordinate reference system.\n * @property {Array<string>} [orderedAxes] Axis order.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n * @property {Array<string>} [collections] Optional collections to append the URL with.\n */\n\n/**\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<string>} collections List of collections to include as query parameter.\n * @return {string} The tile URL template with appended collections query parameter.\n */\nexport function appendCollectionsQueryParam(tileUrlTemplate, collections) {\n  if (!collections.length) {\n    return tileUrlTemplate;\n  }\n\n  // making sure we can always construct a URL instance.\n  const url = new URL(tileUrlTemplate, 'file:/');\n\n  if (url.pathname.split('/').includes('collections')) {\n    logError(\n      'The \"collections\" query parameter cannot be added to collection endpoints',\n    );\n    return tileUrlTemplate;\n  }\n  // According to conformance class\n  // http://www.opengis.net/spec/ogcapi-tiles-1/1.0/conf/collections-selection\n  // commata in the identifiers of the `collections` query parameter\n  // need to be URLEncoded, while the commata separating the identifiers\n  // should not.\n  const encodedCollections = collections\n    .map((c) => encodeURIComponent(c))\n    .join(',');\n\n  url.searchParams.append('collections', encodedCollections);\n  const baseUrl = tileUrlTemplate.split('?')[0];\n  const queryParams = decodeURIComponent(url.searchParams.toString());\n  return `${baseUrl}?${queryParams}`;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType, collections) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @param {Array<string>} [collections] Optional collections to append the URL with.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes,\n  collections,\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  if (collections) {\n    tileUrlTemplate = appendCollectionsQueryParam(tileUrlTemplate, collections);\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits,\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    projection = getProjection(tileMatrixSet.crs);\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${tileMatrixSet.crs}`);\n    }\n  }\n  const orderedAxes = tileMatrixSet.orderedAxes;\n  const backwards =\n    (orderedAxes\n      ? orderedAxes\n          .slice(0, 2)\n          .map((s) => s.replace(/E|X|Lon/i, 'e').replace(/N|Y|Lat/i, 'n'))\n          .join('')\n      : projection.getAxisOrientation().substr(0, 2)) !== 'en';\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  /** @type {import('../Tile.js').UrlFunction} */\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  /** @type {string} */\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.collections,\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes,\n      sourceInfo.collections,\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme',\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet',\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits,\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}