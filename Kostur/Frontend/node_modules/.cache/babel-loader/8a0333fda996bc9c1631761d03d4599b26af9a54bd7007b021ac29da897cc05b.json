{"ast":null,"code":"/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { BooleanType, ColorType, NumberArrayType, NumberType, SizeType, StringType, newParsingContext } from '../expr/expression.js';\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { arrayToGlsl, buildExpression, getStringNumberEquivalent, stringToGlsl, uniformNameForVariable } from '../expr/gpu.js';\nimport { asArray } from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(value, expectedType, parsingContext, compilationContext);\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */`vec${size}`;\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input).split('').reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(vertContext, style[`${prefix}radius`], NumberType);\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(vertContext, style[`${prefix}radius2`], NumberType);\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(vertContext, style[`${prefix}stroke-width`], NumberType)} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(vertContext, style[`${prefix}scale`], SizeType);\n    builder.setSymbolSizeExpression(`${builder.getSymbolSizeExpression()} * ${scale}`);\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[`${prefix}displacement`], NumberArrayType));\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType));\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin = style[`${prefix}cross-origin`] === undefined ? 'anonymous' : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {\n  let offsetExpression = expressionToGlsl(context, style[`${prefix}offset`], NumberArrayType);\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['circle-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['circle-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], ColorType);\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(fragContext, style['circle-radius'], NumberType);\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], NumberType);\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], ColorType);\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], NumberType);\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(fragContext, style['shape-points'], NumberType);\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(fragContext, style['shape-radius2'], NumberType);\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(style, builder, uniforms, vertContext, fragContext) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(fragContext, style['icon-opacity'], NumberType)}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);\n  builder.setSymbolColorExpression(`${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`).setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(`vec2(${expressionToGlsl(vertContext, style['icon-width'], NumberType)}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`);\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(vertContext, style['icon-size'], NumberArrayType);\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);\n    builder.setTextureCoordinateExpression(`(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`);\n  }\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(vertContext, style['icon-anchor'], NumberArrayType);\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(`${builder.getSymbolOffsetExpression()} + ${offsetPx}`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ColorType));\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`stroke-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], NumberType);\n    }\n    fragContext.functions['sampleStrokePattern'] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return samplePremultiplied(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(`${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`);\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], NumberType));\n  }\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], NumberType));\n  }\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], StringType));\n  }\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], StringType));\n  }\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType));\n  }\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n    let dashPattern = style['stroke-line-dash'].map(v => expressionToGlsl(fragContext, v, NumberType));\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], NumberType);\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n    const dashLengthsDef = dashPattern.map((v, i) => `float dashLength${i} = ${v};`);\n    const totalLengthDef = dashPattern.map((v, i) => `dashLength${i}`).join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${i - 2} + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n    fragContext.functions[dashFunctionName] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(`${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ColorType));\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`fill-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    fragContext.functions['sampleFillPattern'] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(`${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`);\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, BooleanType);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n    let callback;\n    if (variable.type === StringType) {\n      callback = () => getStringNumberEquivalent( /** @type {string} */style.variables[variable.name]);\n    } else if (variable.type === ColorType) {\n      callback = () => packColor([...asArray( /** @type {string|Array<number>} */style.variables[variable.name] || '#eee')]);\n    } else if (variable.type === BooleanType) {\n      callback = () => /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;\n    } else {\n      callback = () => ( /** @type {number} */style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(`${getGlslTypeFromType(property.type)} a_prop_${property.name}`);\n  });\n  const attributes = Object.keys(vertContext.properties).map(function (propName) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else if (property.type === StringType) {\n      callback = feature => getStringNumberEquivalent(feature.get(property.name));\n    } else if (property.type === ColorType) {\n      callback = feature => packColor([...asArray(feature.get(property.name) || '#eee')]);\n    } else if (property.type === BooleanType) {\n      callback = feature => feature.get(property.name) ? 1.0 : 0.0;\n    } else {\n      callback = feature => feature.get(property.name);\n    }\n    return {\n      name: property.name,\n      size: getGlslSizeFromType(property.type),\n      callback\n    };\n  });\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n  return {\n    builder: builder,\n    attributes: attributes.reduce((prev, curr) => ({\n      ...prev,\n      [curr.name]: {\n        callback: curr.callback,\n        size: curr.size\n      }\n    }), {}),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["BooleanType","ColorType","NumberArrayType","NumberType","SizeType","StringType","newParsingContext","ShaderBuilder","arrayToGlsl","buildExpression","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","asArray","expressionToGlsl","compilationContext","value","expectedType","parsingContext","style","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","getGlslTypeFromType","size","computeHash","input","hash","JSON","stringify","split","reduce","prev","curr","charCodeAt","toString","parseCommonSymbolProperties","builder","vertContext","prefix","radius","radius2","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseImageProperties","uniforms","textureId","image","Image","crossOrigin","undefined","src","complete","width","height","addUniform","parseImageOffsetProperties","context","imageSize","sampleSize","offsetExpression","parseCircleProperties","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","angle","shapeField","parseIconProperties","sizeExpression","fullsize","offset","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","sampleSizeExpression","spacingExpression","textureName","tintExpression","getStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","uniqueDashKey","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","getFillColorExpression","parseLiteralStyle","inFragmentShader","properties","variables","filter","parsedFilter","setFragmentDiscardExpression","Object","keys","forEach","varName","variable","uniformName","name","callback","propName","property","expression","addVertexShaderFunction","addVarying","addAttribute","attributes","evaluator","feature","get","functionName","addFragmentShaderFunction"],"sources":["C:/Users/PC/eclipse-workspace/apache-tomcat-9.0.89/apache-tomcat-9.0.89/webapps/chocolate-factory-2/Kostur/Frontend/front-app/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  SizeType,\n  StringType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  arrayToGlsl,\n  buildExpression,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\nimport {asArray} from '../color.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  parsingContext.style = compilationContext.style;\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext,\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType,\n    );\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(\n        vertContext,\n        style[`${prefix}radius2`],\n        NumberType,\n      );\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType,\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      SizeType,\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType,\n      ),\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity,\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  let size;\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  if (image.complete && image.width && image.height) {\n    size = arrayToGlsl([image.width, image.height]);\n  } else {\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n    size = `u_texture${textureId}_size`;\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize,\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType,\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] =\n    `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType,\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      SizeType,\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType,\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType,\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] =\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] =\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType,\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType,\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType,\n    );\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType,\n    )}`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId,\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`,\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType,\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType,\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize,\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType,\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType,\n      );\n    }\n    fragContext.functions['sampleStrokePattern'] =\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return samplePremultiplied(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] =\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType),\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType,\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`,\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[dashFunctionName] =\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    fragContext.functions['sampleFillPattern'] =\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return samplePremultiplied(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style,\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      BooleanType,\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  Object.keys(fragContext.variables).forEach(function (varName) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === StringType) {\n      callback = () =>\n        getStringNumberEquivalent(\n          /** @type {string} */ (style.variables[variable.name]),\n        );\n    } else if (variable.type === ColorType) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee',\n          ),\n        ]);\n    } else if (variable.type === BooleanType) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  Object.keys(fragContext.properties).forEach(function (propName) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  Object.keys(vertContext.properties).forEach(function (propName) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\n    );\n  });\n\n  const attributes = Object.keys(vertContext.properties).map(\n    function (propName) {\n      const property = vertContext.properties[propName];\n      let callback;\n      if (property.evaluator) {\n        callback = property.evaluator;\n      } else if (property.type === StringType) {\n        callback = (feature) =>\n          getStringNumberEquivalent(feature.get(property.name));\n      } else if (property.type === ColorType) {\n        callback = (feature) =>\n          packColor([...asArray(feature.get(property.name) || '#eee')]);\n      } else if (property.type === BooleanType) {\n        callback = (feature) => (feature.get(property.name) ? 1.0 : 0.0);\n      } else {\n        callback = (feature) => feature.get(property.name);\n      }\n\n      return {\n        name: property.name,\n        size: getGlslSizeFromType(property.type),\n        callback,\n      };\n    },\n  );\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {},\n    ),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}