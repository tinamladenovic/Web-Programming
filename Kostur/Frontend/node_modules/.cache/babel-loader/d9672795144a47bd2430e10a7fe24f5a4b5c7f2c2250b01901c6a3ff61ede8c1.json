{"ast":null,"code":"/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLBaseTileLayerRenderer, { Uniforms as BaseUniforms, getCacheKey } from './TileLayerBase.js';\nimport { AttributeType } from '../../webgl/Helper.js';\nimport { ELEMENT_ARRAY_BUFFER, STATIC_DRAW } from '../../webgl.js';\nimport { apply as applyTransform } from '../../transform.js';\nimport { boundingExtent, containsCoordinate, getIntersection } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { fromTransform as mat4FromTransform } from '../../vec/mat4.js';\nimport { toSize } from '../../size.js';\nexport const Uniforms = {\n  ...BaseUniforms,\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution',\n  // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX',\n  // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY' // map y coordinate of top edge of texture\n};\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord'\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [{\n  name: Attributes.TEXTURE_COORD,\n  size: 2,\n  type: AttributeType.FLOAT\n}];\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    }\n  }\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);\n    this.helper.flushBufferData(this.indices_);\n  }\n  removeHelper() {\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n    super.removeHelper();\n  }\n  createTileRepresentation(options) {\n    return new TileTexture(options);\n  }\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, tilesWithAlpha);\n    this.helper.useProgram(this.program_, frameState);\n  }\n  renderTile(tileTexture, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {\n    const gl = this.helper.getGL();\n    this.helper.bindBuffer(tileTexture.coords);\n    this.helper.bindBuffer(this.indices_);\n    this.helper.enableAttributes(attributeDescriptions);\n    let textureSlot = 0;\n    while (textureSlot < tileTexture.textures.length) {\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n      this.helper.bindTexture(tileTexture.textures[textureSlot], textureSlot, uniformName);\n      ++textureSlot;\n    }\n    for (let paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {\n      const paletteTexture = this.paletteTextures_[paletteIndex];\n      const texture = paletteTexture.getTexture(gl);\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\n      ++textureSlot;\n    }\n    const viewState = frameState.viewState;\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n    const tile = tileTexture.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n    this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, mat4FromTransform(this.tempMat4, tileTransform));\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n    let gutterExtent = renderExtent;\n    if (gutter > 0) {\n      gutterExtent = tileExtent;\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\n    }\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n    this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);\n    this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);\n    this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);\n    this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);\n    this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);\n    this.helper.drawElements(0, this.indices_.getSize());\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(boundingExtent([coordinate]), viewState.resolution);\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n    const tileTextureCache = this.tileRepresentationCache;\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tile.getState() === TileState.EMPTY) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n      const col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];\n      const row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n      this.paletteTextures_.length = 0;\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n  }\n}\nexport default WebGLTileLayerRenderer;","map":{"version":3,"names":["ReprojDataTile","ReprojTile","TileState","TileTexture","WebGLArrayBuffer","WebGLBaseTileLayerRenderer","Uniforms","BaseUniforms","getCacheKey","AttributeType","ELEMENT_ARRAY_BUFFER","STATIC_DRAW","apply","applyTransform","boundingExtent","containsCoordinate","getIntersection","fromUserExtent","fromTransform","mat4FromTransform","toSize","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","TEXTURE_RESOLUTION","TEXTURE_ORIGIN_X","TEXTURE_ORIGIN_Y","Attributes","TEXTURE_COORD","attributeDescriptions","name","size","type","FLOAT","WebGLTileLayerRenderer","constructor","tileLayer","options","program_","vertexShader_","vertexShader","fragmentShader_","fragmentShader","indices_","fromArray","paletteTextures_","paletteTextures","reset","helper","gl","getGL","paletteTexture","delete","getProgram","afterHelperCreated","flushBufferData","removeHelper","createTileRepresentation","beforeTilesRender","frameState","tilesWithAlpha","useProgram","renderTile","tileTexture","tileTransform","renderExtent","tileResolution","tileSize","tileOrigin","tileExtent","depth","gutter","alpha","bindBuffer","coords","enableAttributes","textureSlot","textures","length","uniformName","bindTexture","paletteIndex","texture","getTexture","viewState","tileWidthWithGutter","tileHeightWithGutter","tile","tileCoord","tileCenterI","tileCenterJ","setUniformMatrixValue","TILE_TRANSFORM","tempMat4","setUniformFloatValue","TRANSITION_ALPHA","DEPTH","gutterExtent","setUniformFloatVec4","RENDER_EXTENT","RESOLUTION","resolution","ZOOM","zoom","drawElements","getSize","getData","pixel","layer","getLayer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","projection","sources","getSources","i","source","tileGrid","getState","getTileGridForProjection","getWrapX","gridExtent","tileTextureCache","tileRepresentationCache","z","getZForResolution","getMinZoom","getTileCoordForCoordAndZ","cacheKey","containsKey","get","EMPTY","loaded","getOrigin","getTileSize","getResolution","col","row","getPixelData","disposeInternal","deleteProgram","deleteBuffer"],"sources":["C:/Users/PC/eclipse-workspace/apache-tomcat-9.0.89/apache-tomcat-9.0.89/webapps/chocolate-factory-2/Kostur/Frontend/front-app/node_modules/ol/renderer/webgl/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayer\n */\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileState from '../../TileState.js';\nimport TileTexture from '../../webgl/TileTexture.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLBaseTileLayerRenderer, {\n  Uniforms as BaseUniforms,\n  getCacheKey,\n} from './TileLayerBase.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {ELEMENT_ARRAY_BUFFER, STATIC_DRAW} from '../../webgl.js';\nimport {apply as applyTransform} from '../../transform.js';\nimport {\n  boundingExtent,\n  containsCoordinate,\n  getIntersection,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {fromTransform as mat4FromTransform} from '../../vec/mat4.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  ...BaseUniforms,\n  TILE_TEXTURE_ARRAY: 'u_tileTextures',\n  TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',\n  TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',\n  TEXTURE_RESOLUTION: 'u_textureResolution', // map units per texture pixel\n  TEXTURE_ORIGIN_X: 'u_textureOriginX', // map x coordinate of left edge of texture\n  TEXTURE_ORIGIN_Y: 'u_textureOriginY', // map y coordinate of top edge of texture\n};\n\nexport const Attributes = {\n  TEXTURE_COORD: 'a_textureCoord',\n};\n\n/**\n * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n */\nconst attributeDescriptions = [\n  {\n    name: Attributes.TEXTURE_COORD,\n    size: 2,\n    type: AttributeType.FLOAT,\n  },\n];\n\n/**\n * @typedef {Object} Options\n * @property {string} vertexShader Vertex shader source.\n * @property {string} fragmentShader Fragment shader source.\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {Array<import(\"../../webgl/PaletteTexture.js\").default>} [paletteTextures] Palette textures.\n * @property {number} [cacheSize=512] The texture cache size.\n */\n\n/**\n * @typedef {import(\"../../layer/WebGLTile.js\").default} LayerType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").TileType} TileTextureType\n */\n/**\n * @typedef {import(\"../../webgl/TileTexture.js\").default} TileTextureRepresentation\n */\n\n/**\n * @classdesc\n * WebGL renderer for tile layers.\n * @extends {WebGLBaseTileLayerRenderer<LayerType, TileTextureType, TileTextureRepresentation>}\n * @api\n */\nclass WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, options);\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_;\n\n    /**\n     * @private\n     */\n    this.vertexShader_ = options.vertexShader;\n\n    /**\n     * @private\n     */\n    this.fragmentShader_ = options.fragmentShader;\n\n    /**\n     * Tiles are rendered as a quad with the following structure:\n     *\n     *  [P3]---------[P2]\n     *   |`           |\n     *   |  `     B   |\n     *   |    `       |\n     *   |      `     |\n     *   |   A    `   |\n     *   |          ` |\n     *  [P0]---------[P1]\n     *\n     * Triangle A: P0, P1, P3\n     * Triangle B: P1, P2, P3\n     *\n     * @private\n     */\n    this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);\n    this.indices_.fromArray([0, 1, 3, 1, 2, 3]);\n\n    /**\n     * @type {Array<import(\"../../webgl/PaletteTexture.js\").default>}\n     * @private\n     */\n    this.paletteTextures_ = options.paletteTextures || [];\n  }\n\n  /**\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    super.reset(options);\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    this.vertexShader_ = options.vertexShader;\n    this.fragmentShader_ = options.fragmentShader;\n    this.paletteTextures_ = options.paletteTextures || [];\n\n    if (this.helper) {\n      this.program_ = this.helper.getProgram(\n        this.fragmentShader_,\n        this.vertexShader_,\n      );\n    }\n  }\n\n  afterHelperCreated() {\n    this.program_ = this.helper.getProgram(\n      this.fragmentShader_,\n      this.vertexShader_,\n    );\n    this.helper.flushBufferData(this.indices_);\n  }\n\n  removeHelper() {\n    if (this.helper) {\n      const gl = this.helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n    }\n\n    super.removeHelper();\n  }\n\n  createTileRepresentation(options) {\n    return new TileTexture(options);\n  }\n\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    super.beforeTilesRender(frameState, tilesWithAlpha);\n    this.helper.useProgram(this.program_, frameState);\n  }\n\n  renderTile(\n    tileTexture,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {\n    const gl = this.helper.getGL();\n    this.helper.bindBuffer(tileTexture.coords);\n    this.helper.bindBuffer(this.indices_);\n    this.helper.enableAttributes(attributeDescriptions);\n\n    let textureSlot = 0;\n    while (textureSlot < tileTexture.textures.length) {\n      const uniformName = `${Uniforms.TILE_TEXTURE_ARRAY}[${textureSlot}]`;\n      this.helper.bindTexture(\n        tileTexture.textures[textureSlot],\n        textureSlot,\n        uniformName,\n      );\n      ++textureSlot;\n    }\n\n    for (\n      let paletteIndex = 0;\n      paletteIndex < this.paletteTextures_.length;\n      ++paletteIndex\n    ) {\n      const paletteTexture = this.paletteTextures_[paletteIndex];\n      const texture = paletteTexture.getTexture(gl);\n      this.helper.bindTexture(texture, textureSlot, paletteTexture.name);\n      ++textureSlot;\n    }\n\n    const viewState = frameState.viewState;\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const tile = tileTexture.tile;\n    const tileCoord = tile.tileCoord;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    this.helper.setUniformMatrixValue(\n      Uniforms.TILE_TRANSFORM,\n      mat4FromTransform(this.tempMat4, tileTransform),\n    );\n\n    this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);\n    this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);\n\n    let gutterExtent = renderExtent;\n    if (gutter > 0) {\n      gutterExtent = tileExtent;\n      getIntersection(gutterExtent, renderExtent, gutterExtent);\n    }\n    this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);\n\n    this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);\n    this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);\n\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_WIDTH,\n      tileWidthWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_PIXEL_HEIGHT,\n      tileHeightWithGutter,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_RESOLUTION,\n      tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_X,\n      tileOrigin[0] +\n        tileCenterI * tileSize[0] * tileResolution -\n        gutter * tileResolution,\n    );\n    this.helper.setUniformFloatValue(\n      Uniforms.TEXTURE_ORIGIN_Y,\n      tileOrigin[1] -\n        tileCenterJ * tileSize[1] * tileResolution +\n        gutter * tileResolution,\n    );\n\n    this.helper.drawElements(0, this.indices_.getSize());\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.\n   */\n  getData(pixel) {\n    const gl = this.helper.getGL();\n    if (!gl) {\n      return null;\n    }\n\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const viewState = frameState.viewState;\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (\n        !containsCoordinate(\n          fromUserExtent(layerExtent, viewState.projection),\n          coordinate,\n        )\n      ) {\n        return null;\n      }\n    }\n\n    // determine last source suitable for rendering at coordinate\n    const sources = layer.getSources(\n      boundingExtent([coordinate]),\n      viewState.resolution,\n    );\n    let i, source, tileGrid;\n    for (i = sources.length - 1; i >= 0; --i) {\n      source = sources[i];\n      if (source.getState() === 'ready') {\n        tileGrid = source.getTileGridForProjection(viewState.projection);\n        if (source.getWrapX()) {\n          break;\n        }\n        const gridExtent = tileGrid.getExtent();\n        if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {\n          break;\n        }\n      }\n    }\n    if (i < 0) {\n      return null;\n    }\n\n    const tileTextureCache = this.tileRepresentationCache;\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const cacheKey = getCacheKey(source, tileCoord);\n      if (!tileTextureCache.containsKey(cacheKey)) {\n        continue;\n      }\n      const tileTexture = tileTextureCache.get(cacheKey);\n      const tile = tileTexture.tile;\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tile.getState() === TileState.EMPTY\n      ) {\n        return null;\n      }\n      if (!tileTexture.loaded) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col =\n        (coordinate[0] - tileOrigin[0]) / tileResolution -\n        tileCoord[1] * tileSize[0];\n\n      const row =\n        (tileOrigin[1] - coordinate[1]) / tileResolution -\n        tileCoord[2] * tileSize[1];\n\n      return tileTexture.getPixelData(col, row);\n    }\n    return null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    const helper = this.helper;\n    if (helper) {\n      const gl = helper.getGL();\n      for (const paletteTexture of this.paletteTextures_) {\n        paletteTexture.delete(gl);\n      }\n      this.paletteTextures_.length = 0;\n\n      gl.deleteProgram(this.program_);\n      delete this.program_;\n      helper.deleteBuffer(this.indices_);\n    }\n    super.disposeInternal();\n    delete this.indices_;\n  }\n}\n\nexport default WebGLTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}