{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getIntersection, getRotatedViewport, getTopLeft, intersects } from '../../extent.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);\n      if (!(tile instanceof ImageTile || tile instanceof ReprojTile) || tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {\n        return null;\n      }\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));\n    }\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    const findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n        const childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n    this.preRender(context, frameState);\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n    let clips, clipZs, currentClip;\n    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */\n        tilesToDraw[tileCoordKey];\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n        const inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    this.postRender(this.context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n      frameState.postRenderFunctions.push( /** @type {import(\"../../Map.js\").PostRenderFunction} */\n      postRenderFunction);\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","ImageTile","ReprojTile","TileRange","TileState","apply","applyTransform","compose","composeTransform","ascending","containsCoordinate","createEmpty","equals","getIntersection","getRotatedViewport","getTopLeft","intersects","fromUserExtent","getUid","toSize","CanvasTileLayerRenderer","constructor","tileLayer","extentChanged","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","isDrawableTile","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","frameState","pixelRatio","projection","viewState","tileSource","getSource","getPreload","getInterimTile","getData","pixel","layer","coordinate","pixelToCoordinateTransform","slice","layerExtent","getExtent","source","getRenderSource","tileGrid","getTileGridForProjection","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","getImage","loadedTileCallback","tiles","zoom","prepareFrame","renderFrame","target","layerState","layerStatesArray","layerIndex","viewResolution","viewCenter","center","rotation","sourceRevision","getRevision","zDirection","extent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","tileRange","getTileRangeForExtentAndZ","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","tmpTileRange","viewport","size","undefined","minX","maxX","minY","maxY","tileCoordIntersectsViewport","uid","toString","inTransition","opacity","endTransition","includes","getAlpha","time","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","length","zs","Object","keys","map","Number","sort","clips","clipZs","currentClip","containerReused","getOpaque","reverse","i","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","tilesToDraw","tileCoordKey","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","clearRect","drawTileImage","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","manageTilePyramid","scheduleExpireCache","postRender","container","image","getTileImage","alpha","alphaChanged","globalAlpha","drawImage","animate","canExpireCache","postRenderFunction","tileSourceKey","expireCache","bind","postRenderFunctions","getKey","preload","tileCallback","wantedTiles","tileQueue","minZoom","tileCount","IDLE","isKeyQueued","enqueue","getTileCoordCenter","useTile","updateCacheSize"],"sources":["C:/Users/PC/eclipse-workspace/apache-tomcat-9.0.89/apache-tomcat-9.0.89/webapps/chocolate-factory-2/Kostur/Frontend/front-app/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport ImageTile from '../../ImageTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   */\n  constructor(tileLayer) {\n    super(tileLayer);\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile(tile) {\n    const tileLayer = this.getLayer();\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return (\n      tileState == TileState.LOADED ||\n      tileState == TileState.EMPTY ||\n      (tileState == TileState.ERROR && !useInterimTilesOnError)\n    );\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const pixelRatio = frameState.pixelRatio;\n    const projection = frameState.viewState.projection;\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = source.getTile(\n        z,\n        tileCoord[1],\n        tileCoord[2],\n        pixelRatio,\n        projection,\n      );\n      if (\n        !(tile instanceof ImageTile || tile instanceof ReprojTile) ||\n        (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY)\n      ) {\n        return null;\n      }\n\n      if (tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(tile.getImage(), col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {Object<number, Object<string, import(\"../../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @param {number} zoom Zoom level.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean|void} If `false`, the tile will not be considered loaded.\n   */\n  loadedTileCallback(tiles, zoom, tile) {\n    if (this.isDrawableTile(tile)) {\n      return super.loadedTileCallback(tiles, zoom, tile);\n    }\n    return false;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return !!this.getLayer().getSource();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const rotation = viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    let extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      extent = getIntersection(\n        extent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource,\n      projection,\n      tilesToDrawByZ,\n    );\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (\n          rotation &&\n          !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n        ) {\n          continue;\n        }\n        const tile = this.getTile(z, x, y, frameState);\n        if (this.isDrawableTile(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            let inTransition = tile.inTransition(uid);\n            if (inTransition && layerState.opacity !== 1) {\n              // Skipping transition when layer is not fully opaque avoids visual artifacts.\n              tile.endTransition(uid);\n              inTransition = false;\n            }\n            if (\n              !this.newTiles_ &&\n              (inTransition || !this.renderedTiles.includes(tile))\n            ) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord,\n          tmpTileRange,\n          tmpExtent,\n        );\n\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord,\n            findLoadedTiles,\n            tmpTileRange,\n            tmpExtent,\n          );\n        }\n      }\n    }\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerExtent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    this.renderedTiles.length = 0;\n    /** @type {Array<number>} */\n    let zs = Object.keys(tilesToDrawByZ).map(Number);\n    zs.sort(ascending);\n\n    let clips, clipZs, currentClip;\n    if (\n      layerState.opacity === 1 &&\n      (!this.containerReused ||\n        tileSource.getOpaque(frameState.viewState.projection))\n    ) {\n      zs = zs.reverse();\n    } else {\n      clips = [];\n      clipZs = [];\n    }\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      const tilesToDraw = tilesToDrawByZ[currentZ];\n      for (const tileCoordKey in tilesToDraw) {\n        const tile = /** @type {import(\"../../ImageTile.js\").default} */ (\n          tilesToDraw[tileCoordKey]\n        );\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = z === currentZ;\n\n        const inTransition =\n          transition && tile.getAlpha(getUid(this), frameState.time) !== 1;\n        let contextSaved = false;\n        if (!inTransition) {\n          if (clips) {\n            // Clip mask for regions in this tile that already filled by a higher z tile\n            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n            for (let i = 0, ii = clips.length; i < ii; ++i) {\n              if (z !== currentZ && currentZ < clipZs[i]) {\n                const clip = clips[i];\n                if (\n                  intersects(\n                    [x, y, x + w, y + h],\n                    [clip[0], clip[3], clip[4], clip[7]],\n                  )\n                ) {\n                  if (!contextSaved) {\n                    context.save();\n                    contextSaved = true;\n                  }\n                  context.beginPath();\n                  // counter-clockwise (outer ring) for current tile\n                  context.moveTo(currentClip[0], currentClip[1]);\n                  context.lineTo(currentClip[2], currentClip[3]);\n                  context.lineTo(currentClip[4], currentClip[5]);\n                  context.lineTo(currentClip[6], currentClip[7]);\n                  // clockwise (inner ring) for higher z tile\n                  context.moveTo(clip[6], clip[7]);\n                  context.lineTo(clip[4], clip[5]);\n                  context.lineTo(clip[2], clip[3]);\n                  context.lineTo(clip[0], clip[1]);\n                  context.clip();\n                }\n              }\n            }\n            clips.push(currentClip);\n            clipZs.push(currentZ);\n          } else {\n            context.clearRect(x, y, w, h);\n          }\n        }\n        this.drawTileImage(\n          tile,\n          frameState,\n          x,\n          y,\n          w,\n          h,\n          tileGutter,\n          transition,\n        );\n        if (clips && !inTransition) {\n          if (contextSaved) {\n            context.restore();\n          }\n          this.renderedTiles.unshift(tile);\n        } else {\n          this.renderedTiles.push(tile);\n        }\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.manageTilePyramid(\n      frameState,\n      tileSource,\n      tileGrid,\n      pixelRatio,\n      projection,\n      extent,\n      z,\n      tileLayer.getPreload(),\n    );\n    this.scheduleExpireCache(frameState, tileSource);\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    return this.container;\n  }\n\n  /**\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function (tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(\n            frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey],\n          );\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../../Map.js\").PostRenderFunction} */ (\n          postRenderFunction\n        ),\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to `preload` levels.\n   * @param {function(import(\"../../Tile.js\").default):void} [tileCallback] Tile callback.\n   * @protected\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    tileCallback,\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    const rotation = frameState.viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          frameState.viewState.center,\n          frameState.viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    let tileCount = 0;\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          if (currentZ - z <= preload) {\n            ++tileCount;\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([\n                  tile,\n                  tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord),\n                  tileResolution,\n                ]);\n              }\n            }\n            if (tileCallback !== undefined) {\n              tileCallback(tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n    tileSource.updateCacheSize(tileCount, projection);\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}